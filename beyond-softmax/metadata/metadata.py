# -*- coding: utf-8 -*-
"""metadata.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17WFtHucf5vDY6VJdIDtD28jdoShVYpFU
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/MyDrive/beyond-softmax-master/

"""import os
import zipfile
import random
import tensorflow as tf
from tensorflow.keras.optimizers import RMSprop
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from shutil import copyfile

data split

import os, random
from shutil import copyfile

def split_data(SOURCE, TRAINING, TESTING, SPLIT_SIZE):
    # 목적지 폴더가 없으면 생성
    os.makedirs(TRAINING, exist_ok=True)
    os.makedirs(TESTING, exist_ok=True)

    # 원본 경로의 파일명들을 모두 가져온다.
    file_names = os.listdir(SOURCE)

    # 가져온 파일명을 잘 섞어준다.
    shuffled_files = random.sample(file_names, len(file_names))

    # 학습용과 테스트용 분리를 위해 인덱스를 구한다.
    index = int(len(shuffled_files) * SPLIT_SIZE)

    # 섞인 파일명 리스트에서, 해당 인덱스만큼 잘라서 학습/테스트 분리
    training_images = shuffled_files[:index]
    test_images = shuffled_files[index:]

    # 학습용 복사
    for file_name in training_images:
        src_file = os.path.join(SOURCE, file_name)
        dst_file = os.path.join(TRAINING, file_name)
        if os.path.getsize(src_file) > 0:
            copyfile(src_file, dst_file)

    # 테스트용 복사
    for file_name in test_images:
        src_file = os.path.join(SOURCE, file_name)
        dst_file = os.path.join(TESTING, file_name)
        if os.path.getsize(src_file) > 0:
            copyfile(src_file, dst_file)


SOURCE_DIR = "/content/drive/MyDrive/beyond-softmax-master/dataset/KITTI/image_2"
TRAINING_DIR = "/content/drive/MyDrive/beyond-softmax-master/dataset/KITTI/train"
TESTING_DIR = "/content/drive/MyDrive/beyond-softmax-master/dataset/KITTI/test"

split_size = 0.55
split_data(SOURCE_DIR, TRAINING_DIR, TESTING_DIR, split_size)

metadata
"""

import os
from PIL import Image

def process_annotations(annotation_dir, image_dir, output_dir):
    """
    Kitti 데이터셋의 annotation 파일과 이미지 파일의 상호 존재 여부를 확인하여
    필요한 정보를 추출하고, 불필요한 경고를 제거합니다.
    """
    class_names = {
        'Car' : 0,
        'Van' : 1,
        'Truck' : 2,
        'Pedestrian' : 3,
        'Person_sitting' : 4,
        'Cyclist' : 5,
        'Tram' : 6,
        'Misc' : 7,
        'DontCare' : 8
    }

    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    class_labels_path = os.path.join(output_dir, 'class_labels.txt')
    image_ids_path = os.path.join(output_dir, 'image_ids.txt')
    image_sizes_path = os.path.join(output_dir, 'image_sizes.txt')
    localization_path = os.path.join(output_dir, 'localization.txt')

    # annotation 파일 목록과 이미지 파일 목록 생성
    anno_files = {os.path.splitext(f)[0] for f in os.listdir(annotation_dir) if f.endswith('.txt')}
    image_files = {os.path.splitext(f)[0] for f in os.listdir(image_dir) if f.endswith('.png') or f.endswith('.jpg')}

    # 교집합을 통해 실제로 존재하는 데이터 쌍만 필터링
    valid_ids = sorted(list(anno_files.intersection(image_files)))

    # 파일 쓰기 모드 열기
    with open(class_labels_path, 'w') as f_labels, \
         open(image_ids_path, 'w') as f_ids, \
         open(image_sizes_path, 'w') as f_sizes, \
         open(localization_path, 'w') as f_loc:

        # 유효한 ID만 순회
        for image_id in valid_ids:
            image_filename = f'{image_id}.png' # .png 확장자로 가정, 필요시 .jpg로 수정

            # image_ids.txt에 파일명 추가
            f_ids.write(f'{image_filename}\n')

            # 이미지 크기 가져와서 image_sizes.txt에 추가
            image_path = os.path.join(image_dir, image_filename)
            with Image.open(image_path) as img:
                width, height = img.size
                f_sizes.write(f'{image_filename},{width},{height}\n')

            # annotation 파일 처리
            annotation_path = os.path.join(annotation_dir, f'{image_id}.txt')
            with open(annotation_path, 'r') as f_anno:
                lines = f_anno.readlines()
                for line in lines:
                    parts = line.strip().split()
                    if len(parts) < 8:
                        continue

                    class_type = parts[0]
                    bbox_xmin = int(float(parts[4]))
                    bbox_ymin = int(float(parts[5]))
                    bbox_xmax = int(float(parts[6]))
                    bbox_ymax = int(float(parts[7]))


                    if class_type in class_names:
                        class_number = class_names[class_type]
                        f_labels.write(f'{image_filename},{class_number}\n')

                    f_loc.write(f'{image_filename},{bbox_xmin},{bbox_ymin},{bbox_xmax},{bbox_ymax}\n')

    print("파일 생성이 완료되었습니다.")

annotation_dir = '/content/drive/MyDrive/beyond-softmax-master/annotations/label_2'
tr_image_dir = '/content/drive/MyDrive/beyond-softmax-master/dataset/KITTI/train'
tr_output_dir = '/content/drive/MyDrive/beyond-softmax-master/metadata/KITTI/train'
ts_image_dir = '/content/drive/MyDrive/beyond-softmax-master/dataset/KITTI/test'
ts_output_dir = '/content/drive/MyDrive/beyond-softmax-master/metadata/KITTI/test'
process_annotations(annotation_dir, tr_image_dir, tr_output_dir)
process_annotations(annotation_dir, ts_image_dir, ts_output_dir)

"""import os
from PIL import Image

def process_annotations_with_multiple_objects(annotation_dir, image_dir, output_dir):
    """
    한 이미지에 여러 객체가 있는 Kitti 데이터셋의 annotation 파일에서
    필요한 정보를 추출하여 class_labels.txt, image_ids.txt,
    image_sizes.txt, localization.txt 파일을 생성합니다.

    Args:
        annotation_dir (str): annotation 파일(.txt)이 있는 디렉토리 경로.
        image_dir (str): 이미지 파일(.jpg)이 있는 디렉토리 경로.
        output_dir (str): 결과 파일(.txt)을 저장할 디렉토리 경로.
    """
    # 클래스 이름을 숫자로 매핑
    class_names = {
        'Car' : 0,
        'Van' : 1,
        'Truck' : 2,
        'Pedestrian' : 3,
        'Person_sitting' : 4,
        'Cyclist' : 5,
        'Tram' : 6,
        'Misc' : 7,
        'DontCare' : 8
    }

    # 출력 디렉토리가 없으면 생성
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # 결과 파일을 저장할 경로 설정
    class_labels_path = os.path.join(output_dir, 'class_labels.txt')
    image_ids_path = os.path.join(output_dir, 'image_ids.txt')
    image_sizes_path = os.path.join(output_dir, 'image_sizes.txt')
    localization_path = os.path.join(output_dir, 'localization.txt')

    # 처리된 이미지 ID를 기록하기 위한 집합
    processed_image_ids = set()

    # 파일 쓰기 모드 열기
    with open(class_labels_path, 'w') as f_labels, \
         open(image_ids_path, 'w') as f_ids, \
         open(image_sizes_path, 'w') as f_sizes, \
         open(localization_path, 'w') as f_loc:

        # annotation 디렉토리의 모든 txt 파일 순회
        for filename in sorted(os.listdir(annotation_dir)):
            if filename.endswith('.txt'):
                image_id = filename.replace('.txt', '')
                image_filename = f'{image_id}.png'

                # 이미지 ID가 아직 처리되지 않았다면 image_ids.txt와 image_sizes.txt에 추가
                if image_id not in processed_image_ids:
                    f_ids.write(f'{image_filename}\n')

                    # 이미지 크기 가져와서 image_sizes.txt에 추가
                    image_path = os.path.join(image_dir, image_filename)
                    try:
                        with Image.open(image_path) as img:
                            width, height = img.size
                            f_sizes.write(f'{image_filename} {width} {height}\n')
                        processed_image_ids.add(image_id)
                    except FileNotFoundError:
                        print(f"Warning: Image file not found for {image_filename}. Skipping...")
                        continue

                # annotation 파일 처리
                annotation_path = os.path.join(annotation_dir, filename)
                with open(annotation_path, 'r') as f_anno:
                    lines = f_anno.readlines()
                    for line in lines:
                        parts = line.strip().split()
                        if len(parts) < 8:
                            continue

                        class_type = parts[0]
                        bbox_xmin = parts[4]
                        bbox_ymin = parts[5]
                        bbox_xmax = parts[6]
                        bbox_ymax = parts[7]

                        # class_labels.txt에 파일명과 클래스 숫자 추가
                        if class_type in class_names:
                            class_number = class_names[class_type]
                            f_labels.write(f'{image_filename} {class_number}\n')

                        # localization.txt에 파일명과 bbox 값 추가
                        f_loc.write(f'{image_filename} {bbox_xmin} {bbox_xmax} {bbox_ymin} {bbox_ymax}\n')

    print("파일 생성이 완료되었습니다.")
"""



